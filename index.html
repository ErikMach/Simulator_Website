<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Simulator</title>
    <meta charset="UTF-8">
<!-- CSP WHEN NEEDED -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">

    <link rel="stylesheet" type="text/css" href="./css/index.css"/>
    <link rel="icon" href="./res/icon.webp"/>
    <link rel="prefetch" href="./res/icon.webp"/>
    <script src="./js/REACT/react.development.js"></script>
    <script src="./js/REACT/react-dom.development.js"></script>

    <script src="./js/THREE/three.js"></script>
    <script src="./js/THREE/SkeletonUtils.js"></script>
    <script src="./js/THREE/GLTFLoader.js"></script>
    <script src="./js/THREE/DRACOLoader.js"></script>
    <script src="./js/THREE/CSS2DRenderer.js"></script>

  </head>
  <style>
:root {

}


:root {
  --color-canvas-subtle: #f6f8fa;
  --color-border-muted: #d8dee4;
  --logo-green: #7fbe42;
  --stone-blue: #68829f;
  --blanched-almond: #fff0d9;
}

* {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  line-height: 1.5;
  font-size: 24px;
  font-weight: 400;
  user-select: none;
}

#canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}

body {
  margin: 0;
  padding: 0;
}

.signInBox {
  display: flex;
  flex-flow: column nowrap;
  justify-content: center;
  align-items: center;
  width: 340px;
  height: 100%;
  color: var(--color-border-muted);
}

.signInBox > img {
  height: 150px;
  width: auto;
}

.formBox {
  display: flex;
  flex-flow: column nowrap;
  justify-content: space-around;
  align-items: stretch;
  width: 340px;
  height: 270px;
  padding: 20px;
  font-size: 14px;
  border-radius: 6px;
  background-color: var(--color-canvas-subtle);
  border: 1px solid var(--color-border-muted);
  box-shadow: 0 0 3px #233e5c;
}
.formBox > * {
  border-radius: 6px;
  font-size: 20px;
  color: black;
}
.formBox > input {
  padding: 3px;
}

.formBox > button {
  padding: 4px;
  color: white;
  font-weight: 500;
  background-color: var(--logo-green);
  cursor: pointer;
}

#passwordErrorMsg {
  position: relative;
  color: red;
  margin: 0;
  font-size: 10;
  height: 0;
  transition: height 0.4s;
  overflow: hidden;
}

#loginPage {
  justify-content: center;
  align-items: center;
  background-color: var(--stone-blue);
}

#activityPage {
  background-color: #fff6c1;
}

.page {
  position: relative;
  width: 100vw;
  height: 100vh;
  top: 0;
  left: 0;
  display: none;
  flex-flow: row wrap;
  justify-content: flex-start;
  align-items: flex-start;
  transition: opacity 0.5s;
}

.transparent {
  opacity: 0 !important;
}
.display {
  display: flex !important;
}
.pHeight {
  height: 1.5em !important;
}

.card {
  position: relative;
  width: 250px;
  height: 180px;
  top: 0;
  margin: 25px;
  background-color: var(--blanched-almond);
  background-position: center;
  background-size: cover;
  background-repeat: no-repeat;
  border: 3px solid gold;
  border-radius: 25px;
  overflow: hidden;
  transition: 0.4s;
}
.card:hover {
  cursor: pointer;
  top: -5px;
  box-shadow: 0 4px 3px var(--stone-blue);
}
.card:active {
  cursor: pointer;
  top: 0;
  box-shadow: none;
}
.card > h3 {
  position: relative;
  position: absolute;
  top: 50%;
  width: 100%;
  padding: 15px 0;
  text-align: center;
  background-color: var(--color-border-muted);
  opacity: 0.8;
}

#explore3DPage {
  flex-flow: column nowrap;
  justify-content: space-around;
}
#explore3DPage > * {
  margin: 0 0 0 40px;
}
.explore0P {
  width: 40%;
}
.explore1P {
  position: absolute;
  top: 0;
  left: 20%;
  width: 60%;
}

.exploreBtnContainer {
  position: relative;
  top: 100px;
  width: calc(100% - 80px);
  display: flex;
  flex-flow: row nowrap;
  justify-content: space-between;
  align-items: center;
}
.exploreBtn, #explore3DPage > button {
  position: relative;
  padding: 5px;
  width: 5em;
  border-radius: 6px;
  cursor: pointer;
  background-color: var(--color-border-muted);
}
.exploreBackBtn {

}
.exploreNextBtn {

}

#labelRenderer {
  position: absolute;
  top: 0;
}
#labelRenderer > div {
  width: 1.8em;
  height: 1.8em;
  display: flex;
  justify-content: center;
  align-items: center;	
  color: white;
  text-shadow: 0 0 3px black;
  background-image: radial-gradient(gold 0%, transparent 55%);
  animation: glow 1s infinite alternate;
}
#labelRenderer > div:hover {
  cursor: pointer;
}

@keyframes glow {
  0% { background-image: radial-gradient(gold 0%, transparent 54%);}
  10% {  background-image: radial-gradient(gold 0%, transparent 56%);}
  20% {  background-image: radial-gradient(gold 0%, transparent 58%);}
  30% {  background-image: radial-gradient(gold 0%, transparent 60%);}
  40% {  background-image: radial-gradient(gold 0%, transparent 63%);}
  50% {  background-image: radial-gradient(gold 0%, transparent 66%);}
  60% {  background-image: radial-gradient(gold 0%, transparent 69%);}
  70% {  background-image: radial-gradient(gold 0%, transparent 72%);}
  80% {  background-image: radial-gradient(gold 0%, transparent 75%);}
  90% {  background-image: radial-gradient(gold 0%, transparent 78%);}
  100% {  background-image: radial-gradient(gold 0%, transparent 80%);}
}
  </style>
  <body>
<!-- Needs constant topBar (logout, profile, ...) -->
    <div class="page currentPage display" id="loginPage"></div>
    <div class="page" id="activityPage"></div>

    <div class="page" id="explorePage"></div>
    <div class="page" id="simulatorPage"></div>
    <div class="page" id="miniProjectsPage"></div>
    <div class="page" id="environmentsPage"></div>

    <canvas id="canvas"></canvas>
    <div class="page" id="explore3DPage"></div>


<script>
//hello
const e = React.createElement;
let userType = "student";
let labelRendererElem, currentElems;
const activityCards = {
  "commercialUser": ["Explore", "Simulator", "Mini Projects", "Environments"],
  "student": ["Explore", "Simulator", "Mini Projects", "Environments"],
  "teacher": ["Explore", "Teaching Material", "Simulator", "Mini Projects", "Environments"]
};
const exploreCards = [
  "RGB LEDs","Switch","Rotary Knob","LED Display","DC Motor"
];
const explore3DElements = {
  "h1":{"tag":"h1","text":"Bananas"}
};
const pieces = {
  "RGB LEDs": {
    "config": ["base4x4", "top4x4", "RGB LEDs"],
    "intro": "Phones, TVs, Christmas lights - coloured lights are everwhere. An RGB LED combines the primary colours of light to produce any colour imaginable!",
    "1": {
      p:"A combination of a single Red, Green and Blue LED put together in a housing that allows the selection of more colours by combining each coloured light.",
      "camera":{"pos":[0,0.05,0.08],"look":[0,0.02,0]}
    },
    "2": {
      "p":"Let's take a look inside!",
      "camera":{"pos":[0,0.06,0.1],"look":[0,0.04,0]},
      "anim": {"top4x4": {"pos":[0,0.06,0]}, "RGB LEDs":{"pos":[0,0.04,0],"rot":[Math.PI/2.7,0,0]}},
      "labels":{"1":[-0.28,-1.5,0],"2":[-0.48,-0.7,0],"3":[-0.62,0.6,0]}
    }
  }
};
const parts = ["base4x4", "top4x4"];

class card extends React.Component {
  render() {
    return e('div', {id: `${this.props.title}Card`, className: "card", style: {backgroundImage: this.props.bgImg}, onClick: this.props.onClick}, [
      e('h3', {key: 10}, this.props.title)
    ]);
  }
}

class explore0 extends React.Component {
  render() {
    return [
      e('h1', {key: 11, className: ""}, this.props.name),
      e('p', {key: 12, className: "explore0P"}, pieces[this.props.name].intro),
      e('button', {key: 13, className: "", onClick: () => {renderFade('explore3DPage', e(explore1, {name: this.props.name}, null));explorePhase(this.props.name, 1)}}, 'Explore')
    ];
  }
}

class explore1 extends React.Component {
  render() {
    return [
      e('h1', {key: 14, className: ""}, this.props.name),
      e('p', {key: 15, className: "explore1P"}, pieces[this.props.name]["1"]["p"]),
      e('div', {key: 18, className: "exploreBtnContainer"}, [
	e('button', {key: 16, className: "exploreBtn exploreBackBtn", onClick: () => {renderFade('explore3DPage', e(explore0, {name: this.props.name}, null));explorePhase(this.props.name, 0)}}, 'Back'),
	e('button', {key: 17, className: "exploreBtn exploreNextBtn", onClick: () => {renderFade('explore3DPage', e(explore2, {name: this.props.name}, null));explorePhase(this.props.name, 2)}}, 'Next')
      ])
    ];
  }
}

class explore2 extends React.Component {
  render() {
    return [
      e('h1', {key: 14, className: ""}, this.props.name),
      e('p', {key: 15, className: "explore1P"}, pieces[this.props.name]["2"]["p"]),
      e('div', {key: 18, className: "exploreBtnContainer"}, [
	e('button', {key: 16, className: "exploreBtn exploreBackBtn", onClick: () => {renderFade('explore3DPage', e(explore1, {name: this.props.name}, null));explorePhase(this.props.name, 1)}}, 'Back'),
	e('button', {key: 17, className: "exploreBtn exploreNextBtn", onClick: () => {renderFade('explore3DPage', e(explore1, {name: this.props.name}, null))}}, 'Next')
      ]),
      e('div', {key: 19, id: "labelRenderer", dangerouslySetInnerHTML: { __html: labelRendererElem.innerHTML}}, null)
    ];
  }
}

console.log(e('h1', {key: 100, className: ""}, null));

const pascalMaBoi = (str) => {
  const arr = str.split(/\s/g);
  arr[0] = arr[0].toLowerCase();
  return arr.join('');
};

const components = {};
components.login = () => {
  return e('div', {className: "signInBox"}, [
    e('img', {key:1, src: "./res/icon.webp"}, null),
    e('h1', {key: 2}, "Sign in to EdgUSim"),
    e('div', {key:3, className: "formBox"}, [
      e('label', {key: 4}, "Username"),
      e('input', {key: 5, placeholder: "", type: "text"}, null),
      e('label', {key: 6, htmlFor: "passwordIn"}, "Password"),
      e('input', {key: 7, id: "passwordIn", placeholder: "", type: "password"}, null),
      e('p', {key: 8, id: "passwordErrorMsg"}, "Sorry, wrong password"),
      e('button', {key: 9, onClick: signIn}, "Sign In")
    ])
  ]);
};
components.activity = activityCards[userType].map((ac, i) => e(card, {key: `ac${i}`, title: ac,  bgImg: `url(./res/img/${ac.split(/\s/g).join('')}.webp)`, onClick: () => {page(`${pascalMaBoi(ac)}Page`)}}, null));
components.explore = exploreCards.map((ec, i) => e(card, {key: `ec${i}`, title: ec, bgImg: `url(./res/img/ComponentWebp/${ec.split(/\s/g).join('_')}.webp)`, onClick: () => {configureExplore(ec);page(`explore3DPage`, true)}}, null));

const configureSite = () => {
  ReactDOM.render(components.login(), document.getElementById('loginPage'));
};

const page = (newPageId, noRender) => {
console.log('Redirecting to:', newPageId);
  document.getElementsByClassName('currentPage')[0].classList.add('transparent');
  document.getElementById(newPageId).classList.add('transparent', 'display');
  setTimeout(() => {
    ReactDOM.render(null, document.getElementsByClassName('currentPage')[0]);
    if (!noRender) {ReactDOM.render(components[newPageId.slice(0,-4)], document.getElementById(newPageId))};
    document.getElementsByClassName('currentPage')[0].classList.remove('display', 'currentPage');
    document.getElementById(newPageId).classList.remove('transparent');
    document.getElementById(newPageId).classList.add('currentPage');
  }, 500);
};

const renderFade = (pageId, newElems) => {
  const currentPage = document.getElementById(pageId);
  currentPage.classList.add('transparent');
  setTimeout(() => {
    ReactDOM.render(null, currentPage);
    ReactDOM.render(newElems, currentPage);
    currentPage.classList.remove('transparent');
  }, 500);

currentElems = newElems;
console.log(currentElems);
};

const signIn = () => {
  if (!verifyPassword()) {wrongPassword(); return;};
  console.log("Password Correct");
  page('activityPage');
};

const verifyPassword = () => {
  //PHP stuff goes here
  return (document.getElementById('passwordIn').value === "") ? true : false;
};
const wrongPassword = () => {
  document.getElementById('passwordErrorMsg').classList.add('pHeight');
};

const activate = (newPageId) => {
  page(newPageId);
};

const configureExplore = (piece) => {
  ReactDOM.render(e(explore0, {name: piece}, null), document.getElementById('explore3DPage'));
  initExplore(piece);
};
const explorePhase = (piece, phaseNum) => {
  const phaseData = pieces[piece][phaseNum];
  const newCam = phaseData["camera"];
  tweenCamera(newCam.pos, newCam.look);
  if (phaseData.anim) {
    for (x in phaseData.anim) {
      tweenAnims(x, phaseData.anim[x]);
    }
  }
  if (phaseData.labels) addLabels(piece, phaseData.labels);

};

const addLabels = (name, labels) => {
  const N = findScenePiece(name);
	    if (!scene.userData.labelRenderer) {
	      const labelRenderer = new THREE.CSS2DRenderer();
	      labelRenderer.domElement.id = "labelRenderer";
//	      document.getElementById("explore3DPage").appendChild(labelRenderer.domElement);
labelRendererElem = labelRenderer.domElement;
	      scene.userData.labelRenderer = labelRenderer;
console.log("appending", labelRenderer.domElement, "to", document.getElementById("explore3DPage"));
	    }
  for (x in labels) {
console.log(x, "at", labels[x]);
	    const numDiv = document.createElement('div');
	    numDiv.className = '';
	    numDiv.textContent = x;
	    const numLabel = new THREE.CSS2DObject(numDiv);
	    numLabel.position.fromArray(labels[x]);
	    scene.children[N].add(numLabel);
	    scene.userData.labels.push(numLabel);
  }
console.log(scene);
};

const tweenAnims = (pieceName, anims) => {
  const delta = 50;
  const N = findScenePiece(pieceName);
  if (anims.pos) {
    const diffVec = vecDiv(vecSub(anims.pos, scene.children[N].position.toArray()), delta);
    let count = 0;
    const tween = () => {
      const dP = vecAdd(scene.children[N].position.toArray(), diffVec);
      scene.children[N].position.fromArray(dP);
      render();
      count++;
      if (count >= delta) {
        cancelAnimationFrame(tweenFrame);
        scene.children[N].position.fromArray(anims.pos);
        render();
      } else {
        tweenFrame = requestAnimationFrame(tween);
      };
    }
    let tweenFrame = requestAnimationFrame(tween);
  };
  if (anims.rot) {
    const diffVec = vecDiv(vecSub(anims.rot, scene.children[N].rotation.toArray().slice(0,-1)), delta);
    let count = 0;
    const tween = () => {
      const dR = vecAdd(scene.children[N].rotation.toArray().slice(0,-1), diffVec);
      scene.children[N].rotation.fromArray(dR);
      render();
      count++;
      if (count >= delta) {
        cancelAnimationFrame(tweenFrame);
        scene.children[N].rotation.fromArray(anims.rot);
        render();
      } else {
        tweenFrame = requestAnimationFrame(tween);
      };
    }
    let tweenFrame = requestAnimationFrame(tween);
  };
};

const findScenePiece = (name) => {
  for (let i=0; i<scene.children.length; i++) {
    if (scene.children[i].name === name.split(/\s/g).join('_')) {
      return i;
    }
  }
};

const tweenCamera = (newPos, newLookAt) => {
  const camera = scene.userData.camera;
  const delta = 50;
  const diffVec = vecDiv(vecSub(newPos, camera.position.toArray()), delta);
  const diffVec1 = vecDiv(vecSub(newLookAt, camera.userData.lookAt), delta);
  let count = 0;
  const tween = () => {
    const dP = vecAdd(camera.position.toArray(), diffVec);
    const dL = vecAdd(camera.userData.lookAt, diffVec1);
    camera.position.set(dP[0], dP[1], dP[2]);
    camera.lookAt(dL[0], dL[1], dL[2]);
    camera.userData.lookAt = dL;
    render();
    count++;
    if (count >= delta) {
      cancelAnimationFrame(tweenFrame);
      camera.position.set(newPos[0], newPos[1], newPos[2]);
      camera.lookAt(newLookAt[0], newLookAt[1], newLookAt[2]);
      render();
    } else {
      tweenFrame = requestAnimationFrame(tween);
    };
  }
  let tweenFrame = requestAnimationFrame(tween);
};

const vecAdd = (vec1, vec2) => {
  if (!checkVec(vec1) || !checkVec(vec2)) {return;};
  if (vec1.length !== vec2.length) {
    console.error(`Vectors are of different dimensions; they cannot be added.`, vec1, vec2);
    return;
  } else {
    const newVec = [];
    vec1.forEach((v, i) => {
      newVec.push(v + vec2[i]);
    });
    return newVec;
  }
};
const vecSub = (vec1, vec2) => {
  if (!checkVec(vec1) || !checkVec(vec2)) {return;};
  if (vec1.length !== vec2.length) {
    console.error(`Vectors are of different dimensions; they cannot be subtracted.`, vec1, vec2);
    return;
  } else {
    const newVec = [];
    vec1.forEach((v, i) => {
      newVec.push(v - vec2[i]);
    });
    return newVec;
  }
};
const vecDiv = (vec, divisor) => {
  if (!checkVec(vec)) {return;};
  const newVec = [];
  vec.forEach(v => {
    newVec.push(v/divisor);
  });
  return newVec;
};
const checkVec = (vec) => {
  if (Array.isArray(vec)) {
    return true;
  } else {
    console.error(vec, `is not an array. It's a(n)`, typeof vec);
    return false;
  }
};

configureSite();
</script>

<script>
let renderer, scene, totalSize;
const canvas = document.getElementById('canvas');
const emptyScene = new THREE.Scene();
const emptyCamera = new THREE.PerspectiveCamera();
const parts3D = new THREE.Object3D();

const loadJSON = (name) => {
  fetch('./res/JSON/' + name + '.tk')
  .then(response => response.json())
  .then(data => {
//??
  });
};

const loadAll = () => {
  const loader = new THREE.GLTFLoader();
  const dracoLoader = new THREE.DRACOLoader();
  dracoLoader.setDecoderPath('./js/THREE/');
  loader.setDRACOLoader(dracoLoader);

  parts.concat(Object.keys(pieces)).forEach(glbFile => {
    loader.load(`./res/GLB/${glbFile}.glb`,
      function(glb) {
	parts3D.userData[glbFile] = glb.scene.children[0];
      },
      function (xhr) {
//        console.log(glbFile, `loaded ${100*xhr.loaded/xhr.total}%`);
        if (xhr.loaded === xhr.total) { 
	totalSize += xhr.total;
        }
      },
      function (err) {
        console.log(err);
      }
    )
  });
};

loadAll();

const initExplore = (piece) => {
console.log(parts3D);
  console.log(piece, 'will be explored here.');

 //SCENE
	scene = new THREE.Scene();
	scene.background = new THREE.Color(0xfff4e2);

	scene.userData.labels = [];

	const element = document.getElementById("explore3DPage");
	scene.userData.element = element; 
	currentStep = 0;

//CAMERA
	const camera = new THREE.PerspectiveCamera(39.6, element.offsetWidth/element.offsetHeight, 0.001, 20);
	camera.position.set(-0.02, 0.1, 0.01);
	camera.lookAt(-0.02, 0, 0);
	camera.userData.lookAt = [-0.02, 0, 0];
	scene.userData.camera = camera;

//ADD PIECES TO SCENE
//CLONE PIECES??
	pieces[piece].config.forEach(elem => {
	  scene.add(parts3D.userData[elem]);
	});

//LIGHTS
//	scene.add(new THREE.HemisphereLight( 0xffffff, 0x404040, 3 ));

//PHYSICALLY CORRECT AND ALL

	const lux = 0.25*Math.PI;

	scene.add( new THREE.AmbientLight( 0xffffff, 1 ) );

	const dirLight0 = new THREE.DirectionalLight( 0xffffff, lux/2 );
	dirLight0.position.set( 0, 0.8, 0 );
	scene.add( dirLight0 );

	const dirLight = new THREE.DirectionalLight( 0xffffff, lux );
	dirLight.position.set( 0, 0.8, 1 );
	scene.add( dirLight );

	const dirLight1 = new THREE.DirectionalLight( 0xffffff, lux );
	dirLight1.position.set( 0.866, 0.8, -0.5 );
	scene.add( dirLight1 );

	const dirLight2 = new THREE.DirectionalLight( 0xffffff, lux );
	dirLight2.position.set( -0.866, 0.8, -0.5 );
	scene.add( dirLight2 );


//GROUND (GridHelper)
	const gridHelper = new THREE.GridHelper( 0.4, 20 );
//	scene.add(gridHelper);

//RENDERER FOR ALL SCENES
    renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true, alpha: true});
    renderer.setClearColor(0xf0f0f3, 0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = false;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.gammaFactor = 2.2;
    renderer.physicallyCorrectLights = true;
    renderer.setScissorTest(true);

    renderer.toneMapping = THREE.LinearToneMapping;
    renderer.toneMappingExposure = 1;



//ACTION
    animate();
    setTimeout(() => {
//      cancelAnimationFrame(animationFrame);
    }, 500);
    window.addEventListener('resize', render);
};

const updateSize = () => {
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (canvas.width !== width || canvas.height !== height) {
      renderer.setSize(width, height, false);
      if (scene.userData.labelRenderer) {
	scene.userData.labelRenderer.setSize(scene.userData.element.clientWidth, scene.userData.element.clientHeight);
      }
    }
};

const animate = () => {
    render();
    animationFrame = requestAnimationFrame(animate);
};

const render = () => {
    updateSize();

    if (!renderer) {cancelAnimationFrame(animationFrame);return;};

    renderer.clear();

	// set the viewport
	const element = scene.userData.element;
	const rect = element.getBoundingClientRect();
	const width = rect.right - rect.left;
	const height = rect.bottom - rect.top;
	const left = rect.left;
	const bottom = renderer.domElement.clientHeight - rect.bottom;
	const camera = scene.userData.camera;
	camera.aspect = width / height;
	camera.updateProjectionMatrix();

	renderer.setViewport( left, bottom, width, height );
	renderer.setScissor( left, bottom, width, height );

    renderer.render(scene, scene.userData.camera);

	if (scene.userData.labelRenderer) {
          if (!scene.userData.labelRenderer.width || !scene.userData.labelRenderer.height) {
	    scene.userData.labelRenderer.setSize(scene.userData.element.clientWidth, scene.userData.element.clientHeight);
          }
	  scene.userData.labelRenderer.render(scene, scene.userData.camera);
//const currentPage = document.getElementById('explore3DPage');
//    ReactDOM.render(currentElems, currentPage);
	}
};

const diseng = () => {
  window.removeEventListener('resize', render);
  cancelAnimationFrame(animationFrame);
  if (scene.userData.labelRenderer) {
    document.getElementById("labelRenderer").parentElement.removeChild(document.getElementById("labelRenderer"));
    scene = null;
  } else {
    scene = null;
  }
  renderer.render(emptyScene, emptyCamera);
  renderer.dispose();
  renderer = null;
};
</script>
  </body>
</html>